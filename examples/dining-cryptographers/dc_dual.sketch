(dining_cryptographers


    (parameters n1 n2)

    (library
      (input_a 0)
      (input_b 0)
      (input_c 0)
      (pick_A 0)
      (pick_B 0)
      (pick_C 0)
      (bxor 2)
      (bnot 1)
      (band 2)
      (bor 2)
      (bone 0)
      (identity 1)
    )



    (blocks
        (in_a 1 ( (input_a) ))
        (in_b 1 ( (input_b) ))
        (in_c 1 ( (input_c) ))
        (share_a_b 1 ( (pick_C) ))
        (share_b_c 1 ( (pick_A) ))
        (share_c_a 1 ( (pick_B) ))
        (private_a n1 ( (bor        (in_a share_a_b share_c_a -) (in_a share_a_b share_c_a -))
                        (band       (in_a share_a_b share_c_a -) (in_a share_a_b share_c_a -))
                        (bxor       (in_a share_a_b share_c_a -) (in_a share_a_b share_c_a -))
                        (bnot       (in_a share_a_b share_c_a -))
                        (identity   (in_a share_a_b share_c_a -))
                        (bone)
                    ))
        (private_b n1 ( (bor        (in_b share_b_c share_a_b -) (in_a share_b_c share_a_b -))
                        (band       (in_b share_b_c share_a_b -) (in_a share_b_c share_a_b -))
                        (bxor       (in_b share_b_c share_a_b -) (in_a share_b_c share_a_b -))
                        (bnot       (in_b share_b_c share_a_b -))
                        (identity   (in_b share_b_c share_a_b -))
                        (bone)
                    ))
        (private_c n1 ( (bor        (in_c share_c_a share_b_c -) (in_a share_c_a share_b_c -))
                        (band       (in_c share_c_a share_b_c -) (in_a share_c_a share_b_c -))
                        (bxor       (in_c share_c_a share_b_c -) (in_a share_c_a share_b_c -))
                        (bnot       (in_c share_c_a share_b_c -))
                        (identity   (in_c share_c_a share_b_c -))
                        (bone)
                    ))
        (announce_a 1 ( (identity   (private_a -))))
        (announce_b 1 ( (identity   (private_b -))))
        (announce_c 1 ( (identity   (private_c -))))
        (consensus n2 ( (bor        (announce_a announce_b announce_c -) (announce_a announce_b announce_c -))
                        (band       (announce_a announce_b announce_c -) (announce_a announce_b announce_c -))
                        (bxor       (announce_a announce_b announce_c -) (announce_a announce_b announce_c -))
                        (bnot       (announce_a announce_b announce_c -))
                        (bone)
                        (identity   (announce_a announce_b announce_c -))
                    ))
    )

    (dual poly
        (decls
            (define-type index (scalar one a b c A B C ab ac aA aB aC bc bA bB bC cA cB cC AB AC BC))
            (define-type poly (-> index bool))
            
            (define forall_def::(-> (-> index bool) bool)
              (lambda (pred::(-> index bool))
                  (and    (pred one)
                          (pred a) (pred b) (pred c) (pred A) (pred B) (pred C) 
                          (pred ab) (pred ac) (pred aA) (pred aB) (pred aC) 
                          (pred bc) (pred bA) (pred bB) (pred bC)
                          (pred cA) (pred cB) (pred cC)
                          (pred AB) (pred AC)
                          (pred BC)
                  )
              )
            )

            (define is_monomial::(-> poly index bool) 
             (lambda (f::poly w::index) (and (f w) (forall_def (lambda (v::index) (or (= v w) (not (f v)) ))))))
            
            (define pick_A::(-> poly bool) 
             (lambda (f::poly) (is_monomial f A)))
            
            (define pick_B::(-> poly bool) 
             (lambda (f::poly) (is_monomial f B)))
            
            (define pick_C::(-> poly bool) 
             (lambda (f::poly) (is_monomial f C)))
            
            (define input_a::(-> poly bool) 
             (lambda (f::poly) (is_monomial f a)))
            
            (define input_b::(-> poly bool) 
             (lambda (f::poly) (is_monomial f b)))
            
            (define input_c::(-> poly bool) 
             (lambda (f::poly) (is_monomial f c)))
            
            (define bone::(-> poly bool) 
             (lambda (f::poly) (is_monomial f one)))
            
            (define identity::(-> poly poly bool)
              (lambda (f::poly g::poly) (forall_def (lambda (w::index) (= (f w) (g w))))))
            
            (define bnot::(-> poly poly bool)
              (lambda (f::poly g::poly)
                 (forall_def (lambda (w::index) (= (= w one) (xor (f w) (g w)) )))))

            (define bxor::(-> poly poly poly bool)
              (lambda (f::poly g::poly h::poly)
                 (forall_def (lambda (w::index) (= (h w) (xor (f w) (g w)))))))
            
            (define is_quadratic::(-> poly bool)
              (lambda (f::poly)
                (or   (f ab) (f ac) (f aA) (f aB) (f aC)
                      (f bc) (f bA) (f bB) (f bC)
                      (f cA) (f cB) (f cC)
                      (f AB) (f AC)
                      (f BC)
                  )
              ))
            
            (define band::(-> poly poly poly bool)
              (lambda (f::poly g::poly h::poly)
               (and   (not (is_quadratic f))
                      (not (is_quadratic g))
                      (= (h one) (and (f one) (g one)))
                      (= (h a) (xor (and (f one) (g a)) (and (f a) (g one)) (and (f a) (g a)) ))
                      (= (h b) (xor (and (f one) (g b)) (and (f b) (g one)) (and (f b) (g b)) ))
                      (= (h c) (xor (and (f one) (g c)) (and (f c) (g one)) (and (f c) (g c)) ))
                      (= (h A) (xor (and (f one) (g A)) (and (f A) (g one)) (and (f A) (g A)) ))
                      (= (h B) (xor (and (f one) (g B)) (and (f B) (g one)) (and (f B) (g B)) ))
                      (= (h C) (xor (and (f one) (g C)) (and (f C) (g one)) (and (f C) (g C)) ))
                      (= (h ab) (xor (and (f a) (g b)) (and (f b) (g a)) ))
                      (= (h ac) (xor (and (f a) (g c)) (and (f c) (g a)) ))
                      (= (h aA) (xor (and (f a) (g A)) (and (f A) (g a)) ))
                      (= (h aB) (xor (and (f a) (g B)) (and (f B) (g a)) ))
                      (= (h aC) (xor (and (f a) (g C)) (and (f C) (g a)) ))
                      (= (h bc) (xor (and (f b) (g c)) (and (f c) (g b)) ))
                      (= (h bA) (xor (and (f b) (g A)) (and (f A) (g b)) ))
                      (= (h bB) (xor (and (f b) (g B)) (and (f B) (g b)) ))
                      (= (h bC) (xor (and (f b) (g C)) (and (f C) (g b)) ))
                      (= (h cA) (xor (and (f c) (g A)) (and (f A) (g c)) ))
                      (= (h cB) (xor (and (f c) (g B)) (and (f B) (g c)) ))
                      (= (h cC) (xor (and (f c) (g C)) (and (f C) (g c)) ))
                      (= (h AB) (xor (and (f A) (g B)) (and (f B) (g A)) ))
                      (= (h AC) (xor (and (f A) (g C)) (and (f C) (g A)) ))
                      (= (h BC) (xor (and (f B) (g C)) (and (f C) (g B)) ))
                  )
              ))
            
            (define bor::(-> poly poly poly bool)
              (lambda (f::poly g::poly h::poly)
               (and   (not (is_quadratic f))
                      (not (is_quadratic g))
                      (= (h one) (xor (f one) (g one) (and (f one) (g one)) ))
                      (= (h a) (xor (f a) (g a) (and (f one) (g a)) (and (f a) (g one)) (and (f a) (g a)) ))
                      (= (h b) (xor (f b) (g b) (and (f one) (g b)) (and (f b) (g one)) (and (f b) (g b)) ))
                      (= (h c) (xor (f c) (g c) (and (f one) (g c)) (and (f c) (g one)) (and (f c) (g c)) ))
                      (= (h A) (xor (f A) (g A) (and (f one) (g A)) (and (f A) (g one)) (and (f A) (g A)) ))
                      (= (h B) (xor (f B) (g B) (and (f one) (g B)) (and (f B) (g one)) (and (f B) (g B)) ))
                      (= (h C) (xor (f C) (g C) (and (f one) (g C)) (and (f C) (g one)) (and (f C) (g C)) ))
                      (= (h ab) (xor (and (f a) (g b)) (and (f b) (g a)) ))
                      (= (h ac) (xor (and (f a) (g c)) (and (f c) (g a)) ))
                      (= (h aA) (xor (and (f a) (g A)) (and (f A) (g a)) ))
                      (= (h aB) (xor (and (f a) (g B)) (and (f B) (g a)) ))
                      (= (h aC) (xor (and (f a) (g C)) (and (f C) (g a)) ))
                      (= (h bc) (xor (and (f b) (g c)) (and (f c) (g b)) ))
                      (= (h bA) (xor (and (f b) (g A)) (and (f A) (g b)) ))
                      (= (h bB) (xor (and (f b) (g B)) (and (f B) (g b)) ))
                      (= (h bC) (xor (and (f b) (g C)) (and (f C) (g b)) ))
                      (= (h cA) (xor (and (f c) (g A)) (and (f A) (g c)) ))
                      (= (h cB) (xor (and (f c) (g B)) (and (f B) (g c)) ))
                      (= (h cC) (xor (and (f c) (g C)) (and (f C) (g c)) ))
                      (= (h AB) (xor (and (f A) (g B)) (and (f B) (g A)) ))
                      (= (h AC) (xor (and (f A) (g C)) (and (f C) (g A)) ))
                      (= (h BC) (xor (and (f B) (g C)) (and (f C) (g B)) ))
                  )
              ))
            
            (define getXOR3::(-> index index index poly) 
              (lambda (x::index y::index z::index) (lambda (v::index) (or (= v x) (= v y) (= v z))))) 
        )

        (ensure
            (poly-identity (poly consensus n2) (getXOR3 a b c))
        )
    )

    (dual random
        (decls
            (define-type random (bitvector 3)) ; Not a very clean approach: The dimension changes with the number of cryptographers
            (define input_a::(-> random bool) (lambda (x::random) (= x "0b000")))
            (define input_b::(-> random bool) (lambda (x::random) (= x "0b000")))
            (define input_c::(-> random bool) (lambda (x::random) (= x "0b000")))
            (define pick_A::(-> random bool) (lambda (x::random) (= x "0b001")))
            (define pick_B::(-> random bool) (lambda (x::random) (= x "0b010")))
            (define pick_C::(-> random bool) (lambda (x::random) (= x "0b100")))
            (define bxor::(-> random random random bool) (lambda (x::random y::random z::random) (= z (bv-xor x y)) ))
            (define bnot::(-> random random bool) (lambda (x::random y::random) (= x y)))
            (define band::(-> random random random bool) (lambda (x::random y::random z::random) (= z "0b000")))
            (define bor::(-> random random random bool) (lambda (x::random y::random z::random) (= z "0b000")))
            (define identity::(-> random random bool) (lambda (x::random y::random) (= x y)))
            (define bone::(-> random bool) (lambda (x::random) (= x "0b000")))
            (define isrand::(-> random bool) (lambda (x::random) (bv-gt x "0b000") ))
            (define dualsourceofrandomness::(-> random bool) (lambda (x::random) (or (= x "0b011") (= x "0b101") (= x "0b110") (= x "0b111"))))
        )
    
        (ensure
            (and
                (isrand (random announce_a 1))
                (isrand (random announce_b 1))
                (isrand (random announce_c 1))
                (dualsourceofrandomness (random announce_a 1))
                (dualsourceofrandomness (random announce_b 1))
                (dualsourceofrandomness (random announce_c 1)) ;Can change it to zero knowledge
            )
        )

    )
)


